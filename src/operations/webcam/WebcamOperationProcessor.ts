import { Client, IOperation, OperationStatus } from "@c8y/client";
import { MqttClient } from "mqtt";
import { OperationProcessor } from "../../models/OperationProcessor";
import { ipcMain, BrowserWindow, IpcMainEvent } from "electron";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

export class WebcamOperationProcessor extends OperationProcessor {
  operationType = "c8y_Webcam";
  protected operationId = "51111";

  private windows = new Map<string, BrowserWindow>();

  async initialize(mqttClient: MqttClient, restClient: Client): Promise<void> {
    return;
  }

  async updateOperationStatusTo(
    restClient: Client,
    operationId: string,
    status: OperationStatus
  ): Promise<void> {
    await restClient.operation.update({
      id: operationId,
      status,
    });
  }

  async processOperation(
    operation: IOperation,
    mqttClient: MqttClient,
    restClient: Client
  ): Promise<boolean> {
    if (operation[this.operationType]) {
      await this.updateOperationStatusTo(
        restClient,
        `${operation.id}`,
        OperationStatus.EXECUTING
      );
      if (operation[`${this.operationType}_OfferRequest`]) {
        await this.processOfferRequest(operation, restClient);
      } else if (operation[`${this.operationType}_Answer`]) {
        await this.processAnser(operation, restClient);
      } else if (operation[`${this.operationType}_Cleanup`]) {
        await this.processCleanupRequest(operation, restClient);
      } else {
        await this.updateOperationStatusTo(
          restClient,
          `${operation.id}`,
          OperationStatus.FAILED
        );
      }
      return true;
    }
    return false;
  }

  protected async processOfferRequest(
    operation: IOperation,
    restClient: Client
  ): Promise<void> {
    this.logger.info("Processing offer request: " + operation.connectionUUID);
    const window = this.createWindow();
    const windowId = window.webContents.id;
    this.logger.info(`Window opened: ${windowId}`);
    this.windows.set(operation.connectionUUID, window);

    const offerListener: (event: IpcMainEvent, ...args: any[]) => void = (
      event,
      offerPayload
    ) => {
      if (event.sender.id !== window.webContents.id) {
        return;
      }
      const { candidates, offerDescription: offer } = JSON.parse(offerPayload);
      this.logger.info(`Received ${candidates.length} candidates.`);
      restClient.operation.update({
        id: operation.id,
        [`${this.operationType}_Offer`]: {
          candidates,
          offer,
        },
        status:
          candidates?.length && offer
            ? OperationStatus.SUCCESSFUL
            : OperationStatus.FAILED,
      });
    };

    ipcMain.on("offer" as any, offerListener);
    window.addListener("closed", () => {
      this.logger.info(`Window closed: ${windowId}`);
      ipcMain.removeListener("offer", offerListener);
    });
  }

  protected async processAnser(
    operation: IOperation,
    restClient: Client
  ): Promise<void> {
    this.logger.info("Processing answer: " + operation.connectionUUID);
    const window = this.windows.get(operation.connectionUUID);
    if (!window) {
      this.logger.info("Window missing: " + operation.connectionUUID);
      return;
    }
    const answer = operation[`${this.operationType}_Answer`];

    window.webContents.send("answer", JSON.stringify(answer));
    await restClient.operation.update({
      id: operation.id,
      status: OperationStatus.SUCCESSFUL,
    });
  }

  protected createWindow(): BrowserWindow {
    // Create the browser window.
    const mainWindow = new BrowserWindow({
      height: 600,
      webPreferences: {
        nodeIntegration: true,
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      },
      show: process.argv.includes("--debugBrowser"),
      width: 800,
    });

    // and load the index.html of the app.
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools.
    mainWindow.webContents.openDevTools();
    return mainWindow;
  }

  protected performCommand(cmd: string): Promise<string> {
    this.logger.info(`Executing command: ${cmd}`);
    return Promise.resolve("");
  }

  private async processCleanupRequest(
    operation: IOperation,
    restClient: Client
  ): Promise<void> {
    this.logger.info("Processing cleanup: " + operation.connectionUUID);
    const window = this.windows.get(operation.connectionUUID);
    if (window) {
      window.close();
    }
    await restClient.operation.update({
      id: operation.id,
      status: OperationStatus.SUCCESSFUL,
    });
  }
}
